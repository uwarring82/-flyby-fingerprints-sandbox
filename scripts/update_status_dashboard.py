#!/usr/bin/env python3
"""Render the status dashboard into README.md and STATUS.md."""

from __future__ import annotations

import datetime as _dt
import json
import os
import re
from pathlib import Path
from typing import Dict, Iterable, List, Mapping, Optional

REPO_ROOT = Path(__file__).resolve().parents[1]
STATUS_PATH = REPO_ROOT / "status" / "status.yml"
DOC_TARGETS = [REPO_ROOT / "README.md", REPO_ROOT / "STATUS.md"]
GUARDIAN_SUMMARY_PATH = REPO_ROOT / "guardian_summary.json"
MARKER_BEGIN = "<!-- DASHBOARD:BEGIN -->"
MARKER_END = "<!-- DASHBOARD:END -->"
AUTOGEN_NOTE = "<!-- (autogenerated, do not edit) -->"

STATUS_EMOJI = {
    "passed": ("🟢", "Passed"),
    "pass": ("🟢", "Passed"),
    "in_review": ("🟡", "In Review"),
    "pending": ("🟡", "Pending"),
    "at_risk": ("🟠", "At Risk"),
    "blocked": ("🔴", "Blocked"),
    "not_started": ("⚪", "Not Started"),
}


def load_status() -> Mapping[str, object]:
    if not STATUS_PATH.exists():
        raise FileNotFoundError(f"Missing status file at {STATUS_PATH}")
    with STATUS_PATH.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def write_status(data: Mapping[str, object]) -> None:
    with STATUS_PATH.open("w", encoding="utf-8") as handle:
        json.dump(data, handle, indent=2, ensure_ascii=False)
        handle.write("\n")


def load_guardian_summary() -> Optional[Mapping[str, object]]:
    if not GUARDIAN_SUMMARY_PATH.exists():
        return None
    with GUARDIAN_SUMMARY_PATH.open("r", encoding="utf-8") as handle:
        try:
            return json.load(handle)
        except json.JSONDecodeError:
            return None


def update_status_metadata(data: Dict[str, object]) -> None:
    timestamp = _dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"
    data["last_updated"] = timestamp

    run_url = os.getenv("GITHUB_RUN_URL")
    if run_url:
        data["provenance_run_url"] = run_url
    else:
        data.setdefault("provenance_run_url", None)



def status_label(status_value: str) -> str:
    emoji, label = STATUS_EMOJI.get(
        status_value,
        ("❔", status_value.replace("_", " ").title()),
    )
    return f"{emoji} {label}"


def format_guardian_summary(summary: Mapping[str, object]) -> str:
    gate_status = summary.get("gate_status")
    bench_passes = summary.get("bench_passes")
    max_coupling = summary.get("max_coupling")

    parts: List[str] = []
    if gate_status:
        parts.append(f"Guardian **{gate_status}**")
    if bench_passes is not None:
        parts.append(f"bench passes: {bench_passes}")
    if max_coupling is not None:
        parts.append(f"max coupling: {max_coupling}")

    if not parts:
        return "Guardian summary unavailable"

    return "; ".join(parts)


def build_dependency_graph(modules: Iterable[Mapping[str, object]]) -> str:
    lines = ["```mermaid", "graph TD"]
    for mod in modules:
        node_label = mod.get("title", mod["key"])
        lines.append(f"    {mod['key']}[{node_label}]")

    seen_edges = set()
    for mod in modules:
        for dep in mod.get("depends_on", []) or []:
            edge = (dep, mod["key"])
            if edge in seen_edges:
                continue
            seen_edges.add(edge)
            lines.append(f"    {dep} --> {mod['key']}")
    lines.append("```")
    return "\n".join(lines)


def build_risk_table(modules: Iterable[Mapping[str, object]]) -> str:
    lines = [
        "| Module | Risk | Driver | Mitigation |",
        "| --- | --- | --- | --- |",
    ]
    for mod in modules:
        risk = mod.get("risk", {}) or {}
        risk_level = risk.get("level", "Unknown")
        driver = risk.get("driver", "—")
        mitigation = risk.get("mitigation", "—")
        lines.append(
            f"| {mod.get('title', mod['key'])} | {risk_level} | {driver} | {mitigation} |"
        )
    return "\n".join(lines)


def build_module_lines(modules: Iterable[Mapping[str, object]]) -> List[str]:
    key_to_title = {mod["key"]: mod.get("title", mod["key"]) for mod in modules}
    lines: List[str] = []
    for mod in modules:
        status_value = status_label(str(mod.get("status", "unknown")))
        completion = mod.get("completion_pct")
        owner = mod.get("owner", "unassigned")
        risk = mod.get("risk", {}) or {}
        risk_level = risk.get("level", "Unknown")
        eta = mod.get("eta", "TBD")
        depends_on = mod.get("depends_on", []) or []
        if depends_on:
            deps_label = ", ".join(key_to_title.get(dep, dep) for dep in depends_on)
        else:
            deps_label = "None"
        milestone = mod.get("next_milestone_issue")
        if milestone:
            milestone_label = f"#{milestone}"
        else:
            milestone_label = "—"
        completion_text = f"~{completion}%" if completion is not None else "~?"
        lines.append(
            "- {status} **{title}** ({completion_text}) — Owner: @{owner} • Risk: {risk_level} "
            "• ETA: {eta} • Dependencies: {deps} • Next milestone: {milestone}".format(
                status=status_value,
                title=mod.get("title", mod["key"]),
                completion_text=completion_text,
                owner=owner,
                risk_level=risk_level,
                eta=eta,
                deps=deps_label,
                milestone=milestone_label,
            )
        )
    return lines


def render_dashboard(data: Mapping[str, object], guardian_summary: Optional[Mapping[str, object]]) -> str:
    header_lines = ["### Status Dashboard"]
    timestamp = data.get("last_updated", "unknown")
    provenance = data.get("provenance_run_url")
    header_line = f"**Last updated:** {timestamp}"
    if provenance:
        header_line += f" · [Provenance]({provenance})"
    else:
        header_line += " · _Provenance pending_"
    header_lines.append(header_line)

    if guardian_summary:
        header_lines.append(format_guardian_summary(guardian_summary))

    modules = data.get("modules", []) or []
    module_lines = build_module_lines(modules)

    graph_block = build_dependency_graph(modules)
    risk_table = build_risk_table(modules)

    parts: List[str] = []
    parts.extend(header_lines)
    parts.append("")
    parts.extend(module_lines)
    parts.append("")
    parts.append(graph_block)
    parts.append("")
    parts.append(risk_table)

    return "\n".join(parts).strip() + "\n"


def replace_block(original: str, replacement: str) -> str:
    pattern = re.compile(
        re.escape(MARKER_BEGIN) + r".*?" + re.escape(MARKER_END),
        re.DOTALL,
    )
    block = (
        f"{MARKER_BEGIN}\n"
        f"{AUTOGEN_NOTE}\n\n"
        f"{replacement}"
        f"{MARKER_END}"
    )
    if not pattern.search(original):
        raise ValueError("Dashboard markers not found in document")
    return pattern.sub(block, original)


def update_documents(dashboard: str) -> None:
    for doc in DOC_TARGETS:
        text = doc.read_text(encoding="utf-8")
        updated = replace_block(text, dashboard)
        doc.write_text(updated, encoding="utf-8")


def main() -> None:
    data = load_status()
    if not isinstance(data, dict):
        raise TypeError("status.yml must define a mapping at the top level")
    update_status_metadata(data)
    guardian_summary = load_guardian_summary()
    dashboard_md = render_dashboard(data, guardian_summary)
    update_documents(dashboard_md)
    write_status(data)


if __name__ == "__main__":
    main()
